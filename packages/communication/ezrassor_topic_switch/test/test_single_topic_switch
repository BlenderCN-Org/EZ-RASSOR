#!/usr/bin/env python
""""""
import time
import rospy
import random
import rostest
import unittest
import threading
import std_msgs.msg


# Some top-level constants for this test suite.
QUEUE_SIZE = 10
SMALL_RANGE = 5
LARGE_RANGE = 10
MINIMUM_RANDOM_INTEGER = 0
MAXIMUM_RANDOM_INTEGER = 1337
PACKAGE_NAME = "ezrassor_topic_switch"
DEFAULT_TEST_NAME = "test_single_topic_switch"
OVERRIDE_TOGGLE_TOPIC = "secondary_override_toggle"


class TestSingleTopicSwitch(unittest.TestCase):
    """"""
    def __init__(self, *arguments, **keyword_arguments):
        """"""
        super(TestSingleTopicSwitch, self).__init__(*arguments, **keyword_arguments)
        rospy.init_node(DEFAULT_TEST_NAME)

        self.__output_data_lock = threading.Lock()
        self.__has_new_output_data = False
        self.__output_data = None

        primary_topic = rospy.get_param(
            rospy.get_name() + "/primary_topic",
        )
        secondary_topic = rospy.get_param(
            rospy.get_name() + "/secondary_topic",
        )
        output_topic = rospy.get_param(
            rospy.get_name() + "/output_topic",
        )
        startup_delay = float(
            rospy.get_param(
                rospy.get_name() + "/startup_delay",
            ),
        )
        self.__communication_delay = float(
            rospy.get_param(
                rospy.get_name() + "/communication_delay",
            ),
        )

        self.primary_publisher = rospy.Publisher(
            primary_topic,
            std_msgs.msg.Int32,
            queue_size=QUEUE_SIZE,
        )
        self.secondary_publisher = rospy.Publisher(
            secondary_topic,
            std_msgs.msg.Int32,
            queue_size=QUEUE_SIZE,
        )
        self.toggle_publisher = rospy.Publisher(
            OVERRIDE_TOGGLE_TOPIC,
            std_msgs.msg.Bool,
            queue_size=QUEUE_SIZE,
        )
        rospy.Subscriber(
            output_topic,
            std_msgs.msg.Int32,
            callback=self.__collect_output_data,
        )
        time.sleep(startup_delay)

    def __collect_output_data(self, data):
        """"""
        self.__output_data_lock.acquire()
        self.__has_new_output_data = True
        self.__output_data = data.data
        self.__output_data_lock.release()

    def __observe_output_data(self):
        """"""
        self.__output_data_lock.acquire()
        output_data = None
        if self.__has_new_output_data:
            self.__has_new_output_data = False
            output_data = self.__output_data
        self.__output_data_lock.release()

        return output_data

    def __publish_and_sleep(self, publisher, data):
        """"""
        publisher.publish(data)
        time.sleep(self.__communication_delay)

    def __test_pipeline(self, publisher, run_range):
        """"""
        for run in run_range:
            random_integer = random.randint(
                MINIMUM_RANDOM_INTEGER,
                MAXIMUM_RANDOM_INTEGER,
            )
            self.__publish_and_sleep(publisher, random_integer)
            self.assertEqual(self.__observe_output_data(), random_integer)

    def test_primary_to_output(self):
        """"""
        self.__publish_and_sleep(toggle_publisher, False)
        self.__test_pipeline(self.primary_publisher, range(1, LARGE_RANGE))

    def test_secondary_to_output(self):
        """"""
        self.__publish(toggle_publisher, True)
        self.__test_pipeline(self.secondary_publisher, range(1, LARGE_RANGE))
        self.__publish(toggle_publisher, False)

    def test_single_switch(self):
        """"""
        self.__publish(toggle_publisher, False)
        self.__test_pipeline(
            self.primary_publisher,
            range(1, random.randrange(5, 10)),
        )
        self.__publish(toggle_publisher, True)
        self.__test_pipeline(
            self.secondary_publisher,
            range(1, random.randrange(5, 10)),
        )
        self.__publish(toggle_publisher, False)

    """
    def test_multiple_switches(self):

        current_state = False
        self.toggle_publisher.publish(current_state)
        for run in range(5):
            if random.random() > .5:
                self.toggle_publisher.publish(not current_state)

        self.__test_pipeline(
            range(random.randrange(5, 10)),
            self.primary_publisher,
        )
        self.toggle_publisher.publish(True)
        time.sleep(self.__communcation_delay)
        self.__test_pipeline(
            range(random.randrange(5, 10)),
            self.secondary_publisher,
        )
        self.toggle_publisher.publish(False)
        pass
    """

#
rostest.rosrun(PACKAGE_NAME, DEFAULT_TEST_NAME, TestSingleTopicSwitch)
