#!/usr/bin/env python
"""

Written by Tiger Sachse.
"""
import time
import json
import rospy
import random
import rostest
import httplib
import unittest
import threading
import std_msgs.msg
import geometry_msgs.msg


#
ITERATION_RANGE = 10
COORDINATE_MAX = 1337
COORDINATE_MIN = -1337
AUTONOMOUS_TOGGLES_INTEGERS = (1, 2, 4, 8)
PACKAGE_NAME = "ezrassor_controller_server"
DEFAULT_TEST_NAME = "test_controller_server"
POST_HEADER = {"content-type" : "application/json"}
WHEEL_INSTRUCTION_STRINGS = ("forward", "backward", "left", "right")


class Instruction():
    """"""
    def __init__(self, name):
        """"""
        self.name = name
        self.__content = None
        self.__content_lock = threading.Lock()

    def update(self, content):
        """"""
        self.__content_lock.acquire()
        self.__content = content
        self.__content_lock.release()

    def get(self):
        """"""
        self.__content_lock.acquire()
        content = self.__content
        self.__content = None
        self.__content_lock.release()

        return content

    def is_none(self):
        """"""
        self.__content_lock.acquire()
        is_none = self.__content == None
        self.__content_lock.release()

        return is_none


class TestControllerServer(unittest.TestCase):
    """"""
    def __init__(self, *arguments, **keyword_arguments):
        """"""
        super(TestControllerServer, self).__init__(*arguments, **keyword_arguments)
        rospy.init_node(DEFAULT_TEST_NAME)
        
        self.__server_url = rospy.get_param(rospy.get_name() + "/server_url")
        self.__port = int(rospy.get_param(rospy.get_name() + "/port"))
        wheel_instructions_topic = rospy.get_param(
            rospy.get_name() + "/wheel_instructions_topic",
        )
        front_arm_instructions_topic = rospy.get_param(
            rospy.get_name() + "/front_arm_instructions_topic",
        )
        back_arm_instructions_topic = rospy.get_param(
            rospy.get_name() + "/back_arm_instructions_topic",
        )
        front_drum_instructions_topic = rospy.get_param(
            rospy.get_name() + "/front_drum_instructions_topic",
        )
        back_drum_instructions_topic = rospy.get_param(
            rospy.get_name() + "/back_drum_instructions_topic",
        )
        autonomous_toggles_topic = "/autonomous_toggles"
        target_coordinates_topic = "/target_coordinates"
        startup_delay = float(
            rospy.get_param(rospy.get_name() + "/startup_delay"),
        )
        self.__communication_delay = float(
            rospy.get_param(rospy.get_name() + "/communication_delay"),
        )

        self.__wheel_instruction = Instruction("wheel_instruction")
        self.__front_arm_instruction = Instruction("front_arm_instruction")
        self.__back_arm_instruction = Instruction("back_arm_instruction")
        self.__front_drum_instruction = Instruction("front_drum_instruction")
        self.__back_drum_instruction = Instruction("back_drum_instruction")
        self.__autonomous_toggles = Instruction("autonomous_toggles")
        self.__target_coordinate = Instruction("target_coordinate")

        rospy.Subscriber(
            wheel_instructions_topic,
            geometry_msgs.msg.Twist,
            callback=self.__wheel_instruction.update,
        )
        rospy.Subscriber(
            front_arm_instructions_topic,
            std_msgs.msg.Float32,
            callback=self.__front_arm_instruction.update,
        )
        rospy.Subscriber(
            back_arm_instructions_topic,
            std_msgs.msg.Float32,
            callback=self.__back_arm_instruction.update,
        )
        rospy.Subscriber(
            front_drum_instructions_topic,
            std_msgs.msg.Float32,
            callback=self.__front_drum_instruction.update,
        )
        rospy.Subscriber(
            back_drum_instructions_topic,
            std_msgs.msg.Float32,
            callback=self.__back_drum_instruction.update,
        )
        rospy.Subscriber(
            autonomous_toggles_topic,
            std_msgs.msg.Int8,
            callback=self.__autonomous_toggles.update,
        )
        rospy.Subscriber(
            target_coordinates_topic,
            geometry_msgs.msg.Point,
            callback=self.__target_coordinate.update,
        )

        # Sleep for a bit to give ROS and all other nodes time to start up.
        time.sleep(startup_delay)

    def __post_and_sleep(self, payload):
        """"""
        connection = httplib.HTTPConnection(self.__server_url, self.__port)
        connection.request("POST", "", json.dumps(payload), POST_HEADER)
        time.sleep(self.__communication_delay)
        #connection.close()

    def __get_random_speed(self):
        """"""
        speed = random.random()
        if random.random() > .5:
            speed = -speed

        return speed

    def setUp(self):
        """"""
        self.__wheel_instruction.update(None)
        self.__front_arm_instruction.update(None)
        self.__back_arm_instruction.update(None)
        self.__front_drum_instruction.update(None)
        self.__back_drum_instruction.update(None)
        self.__autonomous_toggles.update(None)
        self.__target_coordinate.update(None)

    def test_simple_instructions(self):
        """"""
        FLOAT_INSTRUCTIONS = (
            self.__front_arm_instruction,
            self.__back_arm_instruction,
            self.__front_drum_instruction,
            self.__back_drum_instruction,
        )

        for instruction in FLOAT_INSTRUCTIONS:
            for iteration in range(ITERATION_RANGE):
                speed = self.__get_random_speed()
                self.__post_and_sleep({instruction.name : speed})
                self.assertFalse(instruction.is_none())
                self.assertAlmostEqual(instruction.get().data, speed, places=4)

    def test_complex_instructions(self):
        """"""
        def build_complex_instruction():
            """"""
            instruction = {}
            instruction["wheel_instruction"] = random.choice(
                WHEEL_INSTRUCTION_STRINGS,
            )
            instruction["front_arm_instruction"] = self.__get_random_speed()
            instruction["back_arm_instruction"] = self.__get_random_speed()
            instruction["front_drum_instruction"] = self.__get_random_speed()
            instruction["back_drum_instruction"] = self.__get_random_speed()
            instruction["autonomous_toggles"] = random.choice(
                AUTONOMOUS_TOGGLES_INTEGERS,
            )
            instruction["target_coordinate"] = {
                "x" : random.randrange(COORDINATE_MIN, COORDINATE_MAX),
                "y" : random.randrange(COORDINATE_MIN, COORDINATE_MAX),
            }
            instruction.pop(random.choice(instruction.keys()))

            return instruction

        for iteration in range(ITERATION_RANGE):
            instruction = build_complex_instruction()
            self.__post_and_sleep(instruction)
            if not self.__wheel_instruction.is_none():
                self.assertTrue("wheel_instruction" in instruction)
                wheel_instruction = instruction.pop("wheel_instruction")
                if wheel_instruction == "forward":
                    self.assertAlmostEqual(
                        self.__wheel_instruction.get().linear.x,
                        1.0,
                        places=4,
                    )
                elif wheel_instruction == "backward":
                    self.assertAlmostEqual(
                        self.__wheel_instruction.get().linear.x,
                        -1.0,
                        places=4,
                    )
                elif wheel_instruction == "left":
                    self.assertAlmostEqual(
                        self.__wheel_instruction.get().angular.z,
                        1.0,
                        places=4,
                    )
                elif wheel_instruction == "right":
                    self.assertAlmostEqual(
                        self.__wheel_instruction.get().angular.z,
                        -1.0,
                        places=4,
                    )
            if not self.__front_arm_instruction.is_none():
                self.assertTrue("front_arm_instruction" in instruction)
                self.assertAlmostEqual(
                    self.__front_arm_instruction.get().data,
                    instruction.pop("front_arm_instruction"),
                    places=4,
                )
            if not self.__back_arm_instruction.is_none():
                self.assertTrue("back_arm_instruction" in instruction)
                self.assertAlmostEqual(
                    self.__back_arm_instruction.get().data,
                    instruction.pop("back_arm_instruction"),
                    places=4,
                )
            if not self.__front_drum_instruction.is_none():
                self.assertTrue("front_drum_instruction" in instruction)
                self.assertAlmostEqual(
                    self.__front_drum_instruction.get().data,
                    instruction.pop("front_drum_instruction"),
                    places=4,
                )
            if not self.__back_drum_instruction.is_none():
                self.assertTrue("back_drum_instruction" in instruction)
                self.assertAlmostEqual(
                    self.__back_drum_instruction.get().data,
                    instruction.pop("back_drum_instruction"),
                    places=4,
                )
            if not self.__autonomous_toggles.is_none():
                self.assertTrue("autonomous_toggles" in instruction)
                self.assertEqual(
                    self.__autonomous_toggles.get().data,
                    instruction.pop("autonomous_toggles"),
                )
            if not self.__target_coordinate.is_none():
                self.assertTrue("target_coordinate" in instruction)
                given_point = instruction.pop("target_coordinate")
                received_point = self.__target_coordinate.get()
                self.assertEqual(given_point["x"], received_point.x)
                self.assertEqual(given_point["y"], received_point.y)

            self.assertEqual(len(instruction), 0)



            


# Start this node with some default values.
rostest.rosrun(
    PACKAGE_NAME,
    DEFAULT_TEST_NAME,
    TestControllerServer,
)
